---
description: Describe code architecture.
---

# Application code structure

This application is organized in two parts:

1. A minimalist Node.js static server, located in the `server/` directory.
2. A complete Elm client application, located in the `client/` directory.

## Server side: Express \(Node.js\)

We can simply show the whole code of the server since it fits in 21 lines of code, including imports:

{% code-tabs %}
{% code-tabs-item title="server.js" %}
```javascript
const express = require("express");
const app = express();
const path = require("path");
const cors = require("cors");
const compression = require("compression");

// Config based on .env file (transferred to process.env)
require("dotenv").config({ path: path.join(__dirname, ".env") });
const port = parseInt(process.env.SERVER_PORT, 10);
const distDir = path.join(__dirname, process.env.DIST_DIR);

// Middlewares
app.use(compression()); // gzip

// Serve statically the dist/ directory (build artefact)
app.use(express.static(distDir));

// Start server
app.listen(port, () => {
  console.log("Server listening on port %s", port);
});
```
{% endcode-tabs-item %}
{% endcode-tabs %}

It's basically serving the content of the `dist/` directory statically, with gzip compression since the generated `Main.js` file by the client application is roughly 1.2 MB raw but 150 KB gzipped.

## Client side: Elm

The whole client application, running in your browser is an [Elm](http://elm-lang.org/) application. Elm isn't a JavaScript framework, it's functionnal programming language that compiles to JavaScript to run in browsers. Its syntax is inherited from Haskell but far simpler. I'd even argue that it is probably the best language to start programming in, thanks to its clear syntax and [super helpful compiler](http://elm-lang.org/blog/compiler-errors-for-humans).

### The application architecture

Since this is an Elm application, it follows TEA \(The Elm Architecture\). The simplest way of describing TEA is as a unidirectional data transformation flow. The central entity is the `Model`. It contains all and every information about our application state. The visual aspect of our application is called the `View`. The `View` is generated from and only from the `Model`. Meaning there is a function called `view` which takes a `Model`, and returns a `View` \(basically an HTML document\). And finally, all events that happen are generating messages, of type `Msg`. We have a function called `update`, changing the model by reacting to those messages, closing the loop.

![Simplistic representation of TEA \(in Elm code\)](.gitbook/assets/tea-simple.svg)

The above diagram is a simplistic representation of TEA from Elm point of view. In Elm world all functions are "pure" in the functional jargon. Meaning that there is no side effect, meaning that outputs of functions are entirely defined by inputs. There cannot be global variables, real world events, network interaction etc. Basically a program like that would be running in a predestined way from its start to its end. We do not want that, since we want to load images, interact with them etc. This is why an elm program is attached to the Elm runtime, a huge piece of work, provided by the language, transforming all real world events \("side effects"\) into our defined set of messages, of type `Msg`.

![Elm border control with the &quot;real world&quot;](.gitbook/assets/tea-border-draw-io.svg)

Our actual program is better described by the following diagram. The main challenge to keep functions "pure" is to find a way to describe side effects without performing them. In a typical Elm program, side effects are described in three places:

1. View attributes as DOM events listener.
2. Commands \(`Cmd`\) generated by the update function, like making http requests.
3. Subscriptions \(`Sub`\) to outside world events like the time ticking.

The Elm runtime takes those side effect descriptions, perform them, and, whenever there is a result / an answer, transform it into a `Msg` of our choosing and route it to the update function.

![Elm TEA program](.gitbook/assets/tea-draw-io%20%281%29.svg)

### The model states

Explain the three \(four\) states of the application

### The messages

Explain the main messages of the app, and their relationship with states

### The view

Explain the four base view components: action bar, classes sidebar, images sidebar, annotations viewer

### Startup and interactions with JavaScript

Explain Index.html with flags, and ports

